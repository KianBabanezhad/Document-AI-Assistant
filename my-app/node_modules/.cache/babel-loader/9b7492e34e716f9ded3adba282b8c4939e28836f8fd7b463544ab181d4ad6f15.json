{"ast":null,"code":"const handleSend = async () => {\n  if (!inputText.trim()) return;\n  setIsSending(true);\n  setMessages(prev => [...prev, {\n    sender: \"user\",\n    text: inputText\n  }]);\n  const controller = new AbortController();\n  const response = await fetch(\"/api/chat\", {\n    method: \"POST\",\n    body: JSON.stringify({\n      question: inputText\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    signal: controller.signal\n  });\n  const reader = response.body.getReader();\n  const decoder = new TextDecoder(\"utf-8\");\n  let botText = \"\";\n  let buffer = \"\";\n  while (true) {\n    const {\n      value,\n      done\n    } = await reader.read();\n    if (done) break;\n    buffer += decoder.decode(value, {\n      stream: true\n    });\n\n    // Update only when buffer ends with punctuation or newline\n    if (/[\\\\.\\\\!\\\\?\\\\n]$/.test(buffer)) {\n      botText += buffer;\n      buffer = \"\";\n      setMessages(prev => {\n        var _updated;\n        const updated = [...prev];\n        if (((_updated = updated[updated.length - 1]) === null || _updated === void 0 ? void 0 : _updated.sender) === \"bot\") {\n          updated[updated.length - 1].text = botText;\n        } else {\n          updated.push({\n            sender: \"bot\",\n            text: botText\n          });\n        }\n        return updated;\n      });\n    }\n  }\n\n  // Final flush in case something is left\n  if (buffer.length > 0) {\n    botText += buffer;\n    setMessages(prev => {\n      var _updated2;\n      const updated = [...prev];\n      if (((_updated2 = updated[updated.length - 1]) === null || _updated2 === void 0 ? void 0 : _updated2.sender) === \"bot\") {\n        updated[updated.length - 1].text = botText;\n      } else {\n        updated.push({\n          sender: \"bot\",\n          text: botText\n        });\n      }\n      return updated;\n    });\n  }\n  setIsSending(false);\n  setInputText(\"\");\n};","map":{"version":3,"names":["handleSend","inputText","trim","setIsSending","setMessages","prev","sender","text","controller","AbortController","response","fetch","method","body","JSON","stringify","question","headers","signal","reader","getReader","decoder","TextDecoder","botText","buffer","value","done","read","decode","stream","test","_updated","updated","length","push","_updated2","setInputText"],"sources":["E:/Desktop/Projects/Small Language Models/SOP_project/Flask-React_pdf_based/API/my-app/src/App.js"],"sourcesContent":["const handleSend = async () => {\n  if (!inputText.trim()) return;\n\n  setIsSending(true);\n  setMessages(prev => [...prev, { sender: \"user\", text: inputText }]);\n\n  const controller = new AbortController();\n  const response = await fetch(\"/api/chat\", {\n    method: \"POST\",\n    body: JSON.stringify({ question: inputText }),\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    signal: controller.signal\n  });\n\n  const reader = response.body.getReader();\n  const decoder = new TextDecoder(\"utf-8\");\n\n  let botText = \"\";\n  let buffer = \"\";\n\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) break;\n\n    buffer += decoder.decode(value, { stream: true });\n\n    // Update only when buffer ends with punctuation or newline\n    if (/[\\\\.\\\\!\\\\?\\\\n]$/.test(buffer)) {\n      botText += buffer;\n      buffer = \"\";\n\n      setMessages(prev => {\n        const updated = [...prev];\n        if (updated[updated.length - 1]?.sender === \"bot\") {\n          updated[updated.length - 1].text = botText;\n        } else {\n          updated.push({ sender: \"bot\", text: botText });\n        }\n        return updated;\n      });\n    }\n  }\n\n  // Final flush in case something is left\n  if (buffer.length > 0) {\n    botText += buffer;\n    setMessages(prev => {\n      const updated = [...prev];\n      if (updated[updated.length - 1]?.sender === \"bot\") {\n        updated[updated.length - 1].text = botText;\n      } else {\n        updated.push({ sender: \"bot\", text: botText });\n      }\n      return updated;\n    });\n  }\n\n  setIsSending(false);\n  setInputText(\"\");\n};\n"],"mappings":"AAAA,MAAMA,UAAU,GAAG,MAAAA,CAAA,KAAY;EAC7B,IAAI,CAACC,SAAS,CAACC,IAAI,CAAC,CAAC,EAAE;EAEvBC,YAAY,CAAC,IAAI,CAAC;EAClBC,WAAW,CAACC,IAAI,IAAI,CAAC,GAAGA,IAAI,EAAE;IAAEC,MAAM,EAAE,MAAM;IAAEC,IAAI,EAAEN;EAAU,CAAC,CAAC,CAAC;EAEnE,MAAMO,UAAU,GAAG,IAAIC,eAAe,CAAC,CAAC;EACxC,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAC,WAAW,EAAE;IACxCC,MAAM,EAAE,MAAM;IACdC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;MAAEC,QAAQ,EAAEf;IAAU,CAAC,CAAC;IAC7CgB,OAAO,EAAE;MACP,cAAc,EAAE;IAClB,CAAC;IACDC,MAAM,EAAEV,UAAU,CAACU;EACrB,CAAC,CAAC;EAEF,MAAMC,MAAM,GAAGT,QAAQ,CAACG,IAAI,CAACO,SAAS,CAAC,CAAC;EACxC,MAAMC,OAAO,GAAG,IAAIC,WAAW,CAAC,OAAO,CAAC;EAExC,IAAIC,OAAO,GAAG,EAAE;EAChB,IAAIC,MAAM,GAAG,EAAE;EAEf,OAAO,IAAI,EAAE;IACX,MAAM;MAAEC,KAAK;MAAEC;IAAK,CAAC,GAAG,MAAMP,MAAM,CAACQ,IAAI,CAAC,CAAC;IAC3C,IAAID,IAAI,EAAE;IAEVF,MAAM,IAAIH,OAAO,CAACO,MAAM,CAACH,KAAK,EAAE;MAAEI,MAAM,EAAE;IAAK,CAAC,CAAC;;IAEjD;IACA,IAAI,iBAAiB,CAACC,IAAI,CAACN,MAAM,CAAC,EAAE;MAClCD,OAAO,IAAIC,MAAM;MACjBA,MAAM,GAAG,EAAE;MAEXpB,WAAW,CAACC,IAAI,IAAI;QAAA,IAAA0B,QAAA;QAClB,MAAMC,OAAO,GAAG,CAAC,GAAG3B,IAAI,CAAC;QACzB,IAAI,EAAA0B,QAAA,GAAAC,OAAO,CAACA,OAAO,CAACC,MAAM,GAAG,CAAC,CAAC,cAAAF,QAAA,uBAA3BA,QAAA,CAA6BzB,MAAM,MAAK,KAAK,EAAE;UACjD0B,OAAO,CAACA,OAAO,CAACC,MAAM,GAAG,CAAC,CAAC,CAAC1B,IAAI,GAAGgB,OAAO;QAC5C,CAAC,MAAM;UACLS,OAAO,CAACE,IAAI,CAAC;YAAE5B,MAAM,EAAE,KAAK;YAAEC,IAAI,EAAEgB;UAAQ,CAAC,CAAC;QAChD;QACA,OAAOS,OAAO;MAChB,CAAC,CAAC;IACJ;EACF;;EAEA;EACA,IAAIR,MAAM,CAACS,MAAM,GAAG,CAAC,EAAE;IACrBV,OAAO,IAAIC,MAAM;IACjBpB,WAAW,CAACC,IAAI,IAAI;MAAA,IAAA8B,SAAA;MAClB,MAAMH,OAAO,GAAG,CAAC,GAAG3B,IAAI,CAAC;MACzB,IAAI,EAAA8B,SAAA,GAAAH,OAAO,CAACA,OAAO,CAACC,MAAM,GAAG,CAAC,CAAC,cAAAE,SAAA,uBAA3BA,SAAA,CAA6B7B,MAAM,MAAK,KAAK,EAAE;QACjD0B,OAAO,CAACA,OAAO,CAACC,MAAM,GAAG,CAAC,CAAC,CAAC1B,IAAI,GAAGgB,OAAO;MAC5C,CAAC,MAAM;QACLS,OAAO,CAACE,IAAI,CAAC;UAAE5B,MAAM,EAAE,KAAK;UAAEC,IAAI,EAAEgB;QAAQ,CAAC,CAAC;MAChD;MACA,OAAOS,OAAO;IAChB,CAAC,CAAC;EACJ;EAEA7B,YAAY,CAAC,KAAK,CAAC;EACnBiC,YAAY,CAAC,EAAE,CAAC;AAClB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}